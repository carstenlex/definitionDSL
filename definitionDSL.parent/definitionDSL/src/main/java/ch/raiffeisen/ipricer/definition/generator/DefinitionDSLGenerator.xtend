/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
/*
 * generated by Xtext 2.10.0
 */
package ch.raiffeisen.ipricer.definition.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext


import ch.raiffeisen.ipricer.definition.definitionDSL.*;
import ch.raiffeisen.ipricer.definition.definitionDSL.Definition
import ch.raiffeisen.ipricer.definition.definitionDSL.FieldDefinition
import ch.raiffeisen.ipricer.definition.definitionDSL.Data
import ch.raiffeisen.ipricer.definition.definitionDSL.FIELD_TYPE
import ch.raiffeisen.ipricer.definition.definitionDSL.RECORDCLASS

/**
 * Generates code from your model files on save.
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DefinitionDSLGenerator extends AbstractGenerator {

	val targetPackage = "ch.raiffeisen.ipricer.methods."


	override void doGenerate(Resource definition, IFileSystemAccess2 fsa, IGeneratorContext context) {
		/*
            Dateien generieren:
            package: ch.raiffeisen.ipricer.methods.METHODNAME
            METHODNAMEMethod.java
            METHODNAMEParent.java
            METHODNAMEChild.java

            subdirectory "process"
            java-Files: Calculator, Processor, Contributor
        */
		val prefix =targetPackage + definition.getDefinitionName.toLowerCase
		val prefixFile = '/'+(prefix + '.').replaceAll('\\.','/');

		fsa.generateFile( prefixFile + definition.getDefinitionName+ 'Method.java',definition.generateMethodClass(prefix, definition.getDefinitionName))
		fsa.generateFile( prefixFile + definition.getDefinitionName+ 'Child.java',definition.generateChildClass(prefix, definition.getDefinitionName))
		fsa.generateFile( prefixFile + definition.getDefinitionName+ 'Parent.java',definition.generateParentClass(prefix, definition.getDefinitionName))

		//TODO hier mit FileExists erst mal checken, ob die schon da sind
		fsa.generateFile( prefixFile + '/process/Calculator.java',createCalculator(prefix))
		fsa.generateFile( prefixFile + '/process/Contributor.java',createContributor(prefix))
		fsa.generateFile( prefixFile + '/process/Processor.java',createProcessor(prefix, definition.getDefinitionName))


	}

	def String generateParentClass(Resource definition, String packagePrefix, String methodName){
		val dataSection = definition.allContents.toIterable.filter(Data).get(0)

		'''package «packagePrefix» ;

            import «packagePrefix».process.Processor;
            import ch.raiffeisen.ipricer.methods.common.model.ChangeAwareParameter;
            import ch.raiffeisen.ipricer.methods.common.model.RchParent;
            import com.csksoftware.ipricer.*;

            public class «methodName»Parent extends Parent<«methodName»Method, «methodName»Parent, «methodName»Child> implements RchParent<«methodName»Method, «methodName»Parent, «methodName»Child> {



                public «methodName»Parent(final «methodName»Method m) {
                    super(m);

                    try {
                        initialize(m);
                    } catch (Throwable t) {
                        IPricer.LogError("Error during method «methodName»Parent initialization", t);
                        throw t;
                    }
                }

                private void initialize(«methodName»Method m) {
                    //Initializiations
                    adminIn = new StringParam(this, m.getAdminIn());
                    traderIn = new StringParam(this, m.getTraderIn());

                    adminOut = new StringResult(this, m.getAdminOut());
                    traderOut = new StringResult(this, m.getTraderOut());

                     «FOR feld:dataSection.fieldDefinitions»
                        «feld.generateInitializationParent(methodName)»
                    «ENDFOR»
                }

                @Override
                public void onRecalc(«methodName»Method m) {
                    onUpdate(m);
                }

                @Override
                public void onUpdate(«methodName»Method m) {
                    Processor.getInstance().processUpdate(this);
                }

                @Override
                public void onDelete(«methodName»Method m) {
                }

                @Override
                public void onChildDeleted(«methodName»Method method) {
                    Processor.getInstance().processUpdate(this);
                }

                @Override
                public void onDone(«methodName»Method method) {
                }

                @Override
                public «methodName»Child create(String name) {
                    return new «methodName»Child(this);
                }

                @Override
                public «methodName»Method getMethod() {
                    return method();
                }

                @Override
                public String getParentId() {
                    return getId();
                }

                @Override
                public Chain<«methodName»Child> getChildren() {
                    return children();
                }

                @Override
                public StringParam getAdminIn() {
                    return adminIn;
                }

                @Override
                public StringParam getTraderIn() {
                    return traderIn;
                }

                @Override
                public void setAdminOut(String admin) {
                    this.adminOut.set(admin);
                }

                @Override
                public void setTraderOut(String trader) {
                    this.traderOut.set(trader);
                }

                //Deklarationen und getter und setter für die Result-Felder
                private StringParam adminIn;
                private StringParam traderIn;

                private StringResult adminOut;
                private StringResult traderOut;

                «FOR f: dataSection.fieldDefinitions»
                    «f.generateDeclarationParent(methodName)»
                «ENDFOR»
              }
             '''
	}

	def String generateChildClass(Resource definition, String packagePrefix, String methodName){

		'''package «packagePrefix»;

            import «packagePrefix».process.Processor;
            import ch.raiffeisen.ipricer.methods.common.model.RchChild;
            import com.csksoftware.ipricer.Child;
            import com.csksoftware.ipricer.IPricer;

            public class «methodName»Child extends Child<«methodName»Method, «methodName»Parent, «methodName»Child> implements RchChild<«methodName»Method, «methodName»Parent, «methodName»Child> {


                public «methodName»Child(«methodName»Parent p) {
                    super(p);

                    try {
                        initialize(p);
                    } catch (Throwable t) {
                        IPricer.LogError("Error during Method «methodName»Child initialization", t);
                        throw t;
                    }
                }

                private void initialize(«methodName»Parent p) {
                    //Initializiations

                }

                @Override
                public void onDelete(«methodName»Method m, «methodName»Parent p, int paramInt) {
                    Processor.getInstance().processDelete(this);
                }

                @Override
                public void onUpdate(«methodName»Method m, «methodName»Parent p) {
                    Processor.getInstance().processUpdate(this);
                }

                @Override
                public void onMove(«methodName»Method method, «methodName»Parent parent, int var3, int var4) {
                }

                @Override
                public void onDone(«methodName»Method method, «methodName»Parent parent) {
                }

                @Override
                public «methodName»Method getMethod() {
                    return method();
                }

                @Override
                public String getChildId() {
                    return getId();
                }

                @Override
                public «methodName»Parent getParent() {
                    return parent();
                }

                // Deklaratrionen mit getter und setter (setter für Result)
            }


        '''
	}

	def String generateMethodClass(Resource definition, String packagePrefix, String methodName){
		val dataSection = definition.allContents.toIterable.filter(Data).get(0)
		val definitionSection = definition.allContents.toIterable.filter(Definition).get(0)
		''' package ch.raiffeisen.ipricer.methods.«methodName.toLowerCase»;

            import ch.raiffeisen.ipricer.methods.common.Constants;
            import ch.raiffeisen.ipricer.methods.common.model.RchMethod;
            import com.csksoftware.ipricer.*;

            public class «methodName»Method extends Method<«methodName»Method, «methodName»Parent, «methodName»Child> implements RchMethod<«methodName»Method, «methodName»Parent, «methodName»Child> {
                private static final String METHOD_NAME = "«methodName»";
                private static final String METHOD_VERSION = "1.0.0";
                private static final String METHOD_DESCRIPTION = "«definitionSection.guiLabelMethod»";



                public «methodName»Method() {
                    super(METHOD_NAME, METHOD_VERSION, METHOD_DESCRIPTION, "", "");

                    try {
                        initialize();
                    } catch (Throwable t) {
                        IPricer.LogError("Error during method «methodName» initialization", t);
                        throw t;
                    }
                }

                private void initialize() {
                    setMerging(1);

                    methodChainAdmin = new RawParam<>(this, "«methodName».B.IP", "ADF_SRC_10_ID");
                    adminIn = new StringParamLiteral(this, new ParentParamField("ADMIN", "PM_ADMIN"));
                    traderIn = new StringParamLiteral(this, new ParentParamField("TRADER", "PM_TRADER"));
                    adminOut = new StringResultLiteral(this, new ParentParamField("ADMIN", "ADF_SRC_10_ID"), Constants.ADF_ACT_DT, Constants.ADF_ACT_TM);
                    traderOut = new StringResultLiteral(this, new ParentParamField("TRADER", "ADF_SRC_ID"), Constants.ADF_ACT_DT, Constants.ADF_ACT_TM);

                    «FOR feld:dataSection.fieldDefinitions»
                        «feld.generateInitialization(methodName)»
                    «ENDFOR»
                }


                @Override
                public String getName() {
                    return METHOD_NAME;
                }

                @Override
                public «methodName»Parent create(String name) {
                    return new «methodName»Parent(this);
                }

                @Override
                public void onUpdate(String paramString, int paramInt, RawParam<«methodName»Method, «methodName»Parent, «methodName»Child> paramRawParam) {
                    super.onUpdate(paramString, paramInt, paramRawParam);
                }

                @Override
                public Iterable<«methodName»Parent> getParents() {
                    return parents();
                }

                private RawParam<«methodName»Method, «methodName»Parent, «methodName»Child> methodChainAdmin;
                public RawParam<«methodName»Method, «methodName»Parent, «methodName»Child> getMethodChainAdmin() {
                    return methodChainAdmin;
                }

                private StringParamLiteral adminIn;
                private StringParamLiteral traderIn;
                private StringResultLiteral adminOut;
                private StringResultLiteral traderOut;

                @Override
                public StringParamLiteral getAdminIn() {
                    return adminIn;
                }

                @Override
                public StringParamLiteral getTraderIn() {
                    return traderIn;
                }

                @Override
                public StringResultLiteral getAdminOut() {
                    return adminOut;
                }

                @Override
                public StringResultLiteral getTraderOut() {
                    return traderOut;
                }

                //Felddefintionen
                «FOR feld:dataSection.fieldDefinitions»
                    «feld.generateDeclaration(methodName)»
                «ENDFOR»

            }
        '''
	}


	def String generateInitializationParent(FieldDefinition field, String methdoName){
		// U ParentParamField
		// G ParentMutableField
		// R ParentResultField

		// D ChildParamField
		// P ChildMutableField
		// S ChildResultField


		var javaType= ''
		var fieldObject = ''
		var literalType = ''
		switch field.fieldType {
			case FIELD_TYPE::STRING_FIELD : javaType = 'String'
			case FIELD_TYPE::DATE_FIELD : javaType = 'Date'
			case FIELD_TYPE::TIME_FIELD : javaType = 'Time'
			case FIELD_TYPE::DOUBLE_FIELD : javaType = 'Double'
			case FIELD_TYPE::INTEGER_FIELD : javaType = 'Integer'
			case FIELD_TYPE::PRICE_FIELD : javaType = 'Double'
			default: javaType = 'String'
		}

		switch field.recordClass {
			case RECORDCLASS::CHILD_READ_ONLY : {
				fieldObject = 'ChildParamField'
				literalType = 'ParamLiteral'
			}
			case RECORDCLASS::PARENT_READ_ONLY : {
				literalType = 'Param'
				return   '''«field.id.toLowerCase» = new «javaType»«literalType»(this, m.get«field.id.toLowerCase.toFirstUpper»() );'''
			}
			case RECORDCLASS::PARENT_READ_WRITE : {
				literalType = 'Result'
				return   '''«field.id.toLowerCase» = new «javaType»«literalType»(this, m.get«field.id.toLowerCase.toFirstUpper»() );'''
			}

			case RECORDCLASS::PARENT_READ_REFERENCE : {
				literalType = 'Result'
				return   '''«field.id.toLowerCase» = new «javaType»«literalType»(this, m.get«field.id.toLowerCase.toFirstUpper»() );'''
			}

			default: ''''''

		}


	}


	def String generateInitialization(FieldDefinition field, String methdoName){
		// U ParentParamField
		// G ParentMutableField
		// R ParentResultField

		// D ChildParamField
		// P ChildMutableField
		// S ChildResultField


		var javaType= ''
		var fieldObject = ''
		var literalType = ''
		switch field.fieldType {
			case FIELD_TYPE::STRING_FIELD : javaType = 'String'
			case FIELD_TYPE::DATE_FIELD : javaType = 'Date'
			case FIELD_TYPE::TIME_FIELD : javaType = 'Time'
			case FIELD_TYPE::DOUBLE_FIELD : javaType = 'Double'
			case FIELD_TYPE::INTEGER_FIELD : javaType = 'Integer'
			case FIELD_TYPE::PRICE_FIELD : javaType = 'Double'
			default: javaType = 'String'
		}

		switch field.recordClass {
			case RECORDCLASS::CHILD_READ_ONLY : {
				fieldObject = 'ChildParamField'
				literalType = 'ParamLiteral'
			}
			case RECORDCLASS::PARENT_READ_ONLY : {
				fieldObject = 'ParentParamField'
				literalType = 'ParamLiteral'
			}
			case RECORDCLASS::CHILD_READ_WRITE : {
				fieldObject = 'ChildMutableField'
				literalType = 'ResultLiteral'
			}
			case RECORDCLASS::PARENT_READ_WRITE : {
				fieldObject = 'ParentMutableField'
				literalType = 'ResultLiteral'
			}
			case RECORDCLASS::CHILD_READ_REFERENCE :{
				fieldObject = 'ChildResultField'
				literalType = 'ResultLiteral'
			}
			case RECORDCLASS::PARENT_READ_REFERENCE : {
				fieldObject = 'ParentResultField'
				literalType = 'ResultLiteral'
			}
			case RECORDCLASS::METHOD_READ_ONLY : {
				return '''«field.id.toLowerCase» =  new RawParam<>(this,"«methdoName».B.IP","«field.fieldName»");'''
			}
		}

		if (literalType.equals('ResultLiteral')) {
			return   '''«field.id.toLowerCase» = new «javaType»«literalType»(this, new «fieldObject»("«field.name»","«field.fieldName»"),Constants.ADF_ACT_DT, Constants.ADF_ACT_TM);'''
		}else{
			return   '''«field.id.toLowerCase» = new «javaType»«literalType»(this, new «fieldObject»("«field.name»","«field.fieldName»"));'''
		}
	}

	def String generateDeclarationParent(FieldDefinition field, String methodName){
		var javaType = ''
		var literalType = ''
		switch field.fieldType {
			case FIELD_TYPE::STRING_FIELD : javaType = 'String'
			case FIELD_TYPE::DATE_FIELD : javaType = 'Date'
			case FIELD_TYPE::TIME_FIELD : javaType = 'Time'
			case FIELD_TYPE::DOUBLE_FIELD : javaType = 'Double'
			case FIELD_TYPE::INTEGER_FIELD : javaType = 'Integer'
			case FIELD_TYPE::PRICE_FIELD : javaType = 'Double'
			default: javaType = 'String'
		}

		switch field.recordClass {
			case RECORDCLASS::CHILD_READ_ONLY : literalType = 'Param'
			case RECORDCLASS::PARENT_READ_ONLY : literalType = 'Param'
			case RECORDCLASS::CHILD_READ_WRITE : literalType = 'Result'
			case RECORDCLASS::PARENT_READ_WRITE : literalType = 'Result'
			default : literalType = 'Param'
		}
		//Spezialfall RawParam
		if (field.recordClass == RECORDCLASS::METHOD_READ_ONLY) {
			return '''
            private RawParam<«methodName»Method, ?, ?> «field.id.toLowerCase»;
            public RawParam<«methodName»Method, ?, ?> get«field.id.toLowerCase.toFirstUpper»() {return «field.id.toLowerCase»; }

            '''
		}else{
			return '''
            private «javaType»«literalType» «field.id.toLowerCase»;
            public «javaType»«literalType» get«field.id.toLowerCase.toFirstUpper»() { return «field.id.toLowerCase»;}

             '''
		}
	}

	def String generateDeclaration(FieldDefinition field, String methodName){
		// U und D wird xxParamLiteral, xxParamReference, xxResultReference (Allerdings ist das nicht nur durch die Definition zu lösen - hier fehlt uns eine Information -> naming conventions?
		// B wird RawParam
		// P und G wird xxResultLiteral, xxParamLiteral, xxParamReference, xxResultReference (siehe U/D - Problematik)

		var javaType = ''
		var literalType = ''
		switch field.fieldType {
			case FIELD_TYPE::STRING_FIELD : javaType = 'String'
			case FIELD_TYPE::DATE_FIELD : javaType = 'Date'
			case FIELD_TYPE::TIME_FIELD : javaType = 'Time'
			case FIELD_TYPE::DOUBLE_FIELD : javaType = 'Double'
			case FIELD_TYPE::INTEGER_FIELD : javaType = 'Integer'
			case FIELD_TYPE::PRICE_FIELD : javaType = 'Double'
			default: javaType = 'String'
		}

		switch field.recordClass {
			case RECORDCLASS::CHILD_READ_ONLY : literalType = 'ParamLiteral'
			case RECORDCLASS::PARENT_READ_ONLY : literalType = 'ParamLiteral'
			case RECORDCLASS::CHILD_READ_WRITE : literalType = 'ResultLiteral'
			case RECORDCLASS::PARENT_READ_WRITE : literalType = 'ResultLiteral'
			default : literalType = 'ParamLiteral'
		}

		//Spezialfall RawParam
		if (field.recordClass == RECORDCLASS::METHOD_READ_ONLY) {
			return '''
            private RawParam<«methodName»Method, ?, ?> «field.id.toLowerCase»;
            public RawParam<«methodName»Method, ?, ?> get«field.id.toLowerCase.toFirstUpper»() {return «field.id.toLowerCase»; }

            '''
		}else{
			return '''
            private «javaType»«literalType» «field.id.toLowerCase»;
            public «javaType»«literalType» get«field.id.toLowerCase.toFirstUpper»() { return «field.id.toLowerCase»;}

             '''
		}

	}

	def String getDefinitionName(Resource resource){
		resource.getContents.filter(typeof(Definition)).map[methodName].get(0)
	}

	def String createCalculator(String prefix){
		'''
            package «prefix».process;

            public final class Calculator {

                private Calculator() {
                    // singleton
                }

                private static class SingletonHolder {
                    static final Calculator instance = new Calculator();
                }

                public static Calculator getInstance() {
                    return SingletonHolder.instance;
                }
            }
        '''
	}

	def String createContributor(String prefix){
		'''
            package «prefix».process;


            public final class Contributor {

                private Contributor() {
                    // singleton
                }

                private static class SingletonHolder {
                    static final Contributor instance = new Contributor();
                }

                public static Contributor getInstance() {
                    return Contributor.SingletonHolder.instance;
                }
            }
        '''
	}

	def String createProcessor(String prefix, String methodName){
		'''
            package «prefix».process;

            import «prefix».«methodName»Child;
            import «prefix».«methodName»Method;
            import «prefix».«methodName»Parent;
            import ch.raiffeisen.ipricer.methods.common.model.BaseProcessor;
            import com.csksoftware.ipricer.RawParam;

            public final class Processor extends BaseProcessor<«methodName»Method, «methodName»Parent, «methodName»Child> {

                private Processor() {
                    // singleton
                }

                private static class SingletonHolder {
                    static final Processor instance = new Processor();
                }

                public static Processor getInstance() {
                    return SingletonHolder.instance;
                }

                @Override
                protected void processMethodUpdate(«methodName»Method method, String paramString, RawParam<«methodName»Method, «methodName»Parent, «methodName»Child> methodParam) {
                    // no method parameters defined
                }

                @Override
                protected void processParentUpdate(«methodName»Parent p, boolean enforceRedistribution) {

                }

                @Override
                protected void processChildUpdate(«methodName»Child c, boolean enforceRedistribution) {

                }

                @Override
                protected void processParentDelete(«methodName»Parent parent) {
                    //
                }

                @Override
                protected void processChildDelete(«methodName»Child child) {
                    processUpdate(child);
                }
            }

        '''
	}
}
