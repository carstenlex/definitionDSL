/*
 * generated by Xtext 2.9.2
 */
package ch.raiffeisen.ipricer.definition.serializer;

import ch.raiffeisen.ipricer.definition.definitionDSL.Data;
import ch.raiffeisen.ipricer.definition.definitionDSL.Definition;
import ch.raiffeisen.ipricer.definition.definitionDSL.DefinitionDSLPackage;
import ch.raiffeisen.ipricer.definition.definitionDSL.FieldDefinition;
import ch.raiffeisen.ipricer.definition.definitionDSL.InitDefinition;
import ch.raiffeisen.ipricer.definition.definitionDSL.InitSection;
import ch.raiffeisen.ipricer.definition.definitionDSL.OptionContrib;
import ch.raiffeisen.ipricer.definition.definitionDSL.OptionListSection;
import ch.raiffeisen.ipricer.definition.definitionDSL.OptionMaskSection;
import ch.raiffeisen.ipricer.definition.definitionDSL.OptionRange;
import ch.raiffeisen.ipricer.definition.definitionDSL.OptionStrict;
import ch.raiffeisen.ipricer.definition.definitionDSL.OptionValproc;
import ch.raiffeisen.ipricer.definition.definitionDSL.TypeMaskDefinition;
import ch.raiffeisen.ipricer.definition.definitionDSL.TypeMaskSection;
import ch.raiffeisen.ipricer.definition.definitionDSL.UnderlyingListDefintion;
import ch.raiffeisen.ipricer.definition.definitionDSL.UnderlyingListSection;
import ch.raiffeisen.ipricer.definition.definitionDSL.UnderlyingMaskDefinition;
import ch.raiffeisen.ipricer.definition.definitionDSL.UnderlyingMaskSection;
import ch.raiffeisen.ipricer.definition.services.DefinitionDSLGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DefinitionDSLSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DefinitionDSLGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DefinitionDSLPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DefinitionDSLPackage.DATA:
				sequence_Data(context, (Data) semanticObject); 
				return; 
			case DefinitionDSLPackage.DEFINITION:
				sequence_Definition(context, (Definition) semanticObject); 
				return; 
			case DefinitionDSLPackage.FIELD_DEFINITION:
				sequence_FieldDefinition(context, (FieldDefinition) semanticObject); 
				return; 
			case DefinitionDSLPackage.INIT_DEFINITION:
				sequence_InitDefinition(context, (InitDefinition) semanticObject); 
				return; 
			case DefinitionDSLPackage.INIT_SECTION:
				sequence_InitSection(context, (InitSection) semanticObject); 
				return; 
			case DefinitionDSLPackage.OPTION_CONTRIB:
				sequence_OptionContrib(context, (OptionContrib) semanticObject); 
				return; 
			case DefinitionDSLPackage.OPTION_LIST_SECTION:
				sequence_OptionListSection(context, (OptionListSection) semanticObject); 
				return; 
			case DefinitionDSLPackage.OPTION_MASK_SECTION:
				sequence_OptionMaskSection(context, (OptionMaskSection) semanticObject); 
				return; 
			case DefinitionDSLPackage.OPTION_RANGE:
				sequence_OptionRange(context, (OptionRange) semanticObject); 
				return; 
			case DefinitionDSLPackage.OPTION_STRICT:
				sequence_OptionStrict(context, (OptionStrict) semanticObject); 
				return; 
			case DefinitionDSLPackage.OPTION_VALPROC:
				sequence_OptionValproc(context, (OptionValproc) semanticObject); 
				return; 
			case DefinitionDSLPackage.TYPE_MASK_DEFINITION:
				sequence_TypeMaskDefinition(context, (TypeMaskDefinition) semanticObject); 
				return; 
			case DefinitionDSLPackage.TYPE_MASK_SECTION:
				sequence_TypeMaskSection(context, (TypeMaskSection) semanticObject); 
				return; 
			case DefinitionDSLPackage.UNDERLYING_LIST_DEFINTION:
				sequence_UnderlyingListDefintion(context, (UnderlyingListDefintion) semanticObject); 
				return; 
			case DefinitionDSLPackage.UNDERLYING_LIST_SECTION:
				sequence_UnderlyingListSection(context, (UnderlyingListSection) semanticObject); 
				return; 
			case DefinitionDSLPackage.UNDERLYING_MASK_DEFINITION:
				sequence_UnderlyingMaskDefinition(context, (UnderlyingMaskDefinition) semanticObject); 
				return; 
			case DefinitionDSLPackage.UNDERLYING_MASK_SECTION:
				sequence_UnderlyingMaskSection(context, (UnderlyingMaskSection) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Data returns Data
	 *
	 * Constraint:
	 *     fieldDefinitions+=FieldDefinition*
	 */
	protected void sequence_Data(ISerializationContext context, Data semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Definition returns Definition
	 *
	 * Constraint:
	 *     (
	 *         methodName=ID 
	 *         guiLabelMethod=STRING 
	 *         guiLabelParent=STRING 
	 *         guiLabelChild=STRING 
	 *         data=Data 
	 *         initSection=InitSection 
	 *         typeMaskSection=TypeMaskSection 
	 *         underlyingListSection=UnderlyingListSection 
	 *         underlyingMaskSection=UnderlyingMaskSection 
	 *         optionListSection=OptionListSection 
	 *         optionListLabelSection=OptionListLabelSection 
	 *         optionMaskSection=OptionMaskSection 
	 *         (eventuellTclProcedures+=ID | eventuellTclProcedures+=ANY_OTHER)*
	 *     )
	 */
	protected void sequence_Definition(ISerializationContext context, Definition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FieldDefinition returns FieldDefinition
	 *
	 * Constraint:
	 *     (
	 *         fieldType=FIELD_TYPE 
	 *         id=ID 
	 *         name=STRING 
	 *         access=ROLE 
	 *         recordClass=RECORDCLASS 
	 *         fieldName=ID 
	 *         length=INT? 
	 *         options+=Option*
	 *     )
	 */
	protected void sequence_FieldDefinition(ISerializationContext context, FieldDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InitDefinition returns InitDefinition
	 *
	 * Constraint:
	 *     (id=ID initValue=STRING)
	 */
	protected void sequence_InitDefinition(ISerializationContext context, InitDefinition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DefinitionDSLPackage.Literals.INIT_DEFINITION__ID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DefinitionDSLPackage.Literals.INIT_DEFINITION__ID));
			if (transientValues.isValueTransient(semanticObject, DefinitionDSLPackage.Literals.INIT_DEFINITION__INIT_VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DefinitionDSLPackage.Literals.INIT_DEFINITION__INIT_VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInitDefinitionAccess().getIdIDTerminalRuleCall_1_0(), semanticObject.getId());
		feeder.accept(grammarAccess.getInitDefinitionAccess().getInitValueSTRINGTerminalRuleCall_2_0(), semanticObject.getInitValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InitSection returns InitSection
	 *
	 * Constraint:
	 *     initDefinitions+=InitDefinition*
	 */
	protected void sequence_InitSection(ISerializationContext context, InitSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns OptionContrib
	 *     OptionContrib returns OptionContrib
	 *
	 * Constraint:
	 *     contrib?='-contrib'
	 */
	protected void sequence_OptionContrib(ISerializationContext context, OptionContrib semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DefinitionDSLPackage.Literals.OPTION_CONTRIB__CONTRIB) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DefinitionDSLPackage.Literals.OPTION_CONTRIB__CONTRIB));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionContribAccess().getContribContribKeyword_0(), semanticObject.isContrib());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OptionListSection returns OptionListSection
	 *
	 * Constraint:
	 *     optionListDefinitions+=UnderlyingListDefintion*
	 */
	protected void sequence_OptionListSection(ISerializationContext context, OptionListSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OptionMaskSection returns OptionMaskSection
	 *
	 * Constraint:
	 *     optionMaskDefinitions+=TypeMaskDefinition*
	 */
	protected void sequence_OptionMaskSection(ISerializationContext context, OptionMaskSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Option returns OptionRange
	 *     OptionRange returns OptionRange
	 *
	 * Constraint:
	 *     (min=INT max=INT)
	 */
	protected void sequence_OptionRange(ISerializationContext context, OptionRange semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DefinitionDSLPackage.Literals.OPTION_RANGE__MIN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DefinitionDSLPackage.Literals.OPTION_RANGE__MIN));
			if (transientValues.isValueTransient(semanticObject, DefinitionDSLPackage.Literals.OPTION_RANGE__MAX) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DefinitionDSLPackage.Literals.OPTION_RANGE__MAX));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionRangeAccess().getMinINTTerminalRuleCall_2_0(), semanticObject.getMin());
		feeder.accept(grammarAccess.getOptionRangeAccess().getMaxINTTerminalRuleCall_3_0(), semanticObject.getMax());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns OptionStrict
	 *     OptionStrict returns OptionStrict
	 *
	 * Constraint:
	 *     strict?='-strict'
	 */
	protected void sequence_OptionStrict(ISerializationContext context, OptionStrict semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DefinitionDSLPackage.Literals.OPTION_STRICT__STRICT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DefinitionDSLPackage.Literals.OPTION_STRICT__STRICT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionStrictAccess().getStrictStrictKeyword_0(), semanticObject.isStrict());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Option returns OptionValproc
	 *     OptionValproc returns OptionValproc
	 *
	 * Constraint:
	 *     (valproc='-valproc' tclProc=ID)
	 */
	protected void sequence_OptionValproc(ISerializationContext context, OptionValproc semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DefinitionDSLPackage.Literals.OPTION_VALPROC__VALPROC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DefinitionDSLPackage.Literals.OPTION_VALPROC__VALPROC));
			if (transientValues.isValueTransient(semanticObject, DefinitionDSLPackage.Literals.OPTION_VALPROC__TCL_PROC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DefinitionDSLPackage.Literals.OPTION_VALPROC__TCL_PROC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionValprocAccess().getValprocValprocKeyword_0_0(), semanticObject.getValproc());
		feeder.accept(grammarAccess.getOptionValprocAccess().getTclProcIDTerminalRuleCall_1_0(), semanticObject.getTclProc());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     TypeMaskDefinition returns TypeMaskDefinition
	 *
	 * Constraint:
	 *     (id=ID row=INT col=INT (width=INT | separator='-sep'))
	 */
	protected void sequence_TypeMaskDefinition(ISerializationContext context, TypeMaskDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TypeMaskSection returns TypeMaskSection
	 *
	 * Constraint:
	 *     typeMaskDefinitions+=TypeMaskDefinition*
	 */
	protected void sequence_TypeMaskSection(ISerializationContext context, TypeMaskSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnderlyingListDefintion returns UnderlyingListDefintion
	 *
	 * Constraint:
	 *     (id=ID width=INT title=STRING*)
	 */
	protected void sequence_UnderlyingListDefintion(ISerializationContext context, UnderlyingListDefintion semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnderlyingListSection returns UnderlyingListSection
	 *
	 * Constraint:
	 *     underlyingListDefinitions+=UnderlyingListDefintion*
	 */
	protected void sequence_UnderlyingListSection(ISerializationContext context, UnderlyingListSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnderlyingMaskDefinition returns UnderlyingMaskDefinition
	 *
	 * Constraint:
	 *     (id=ID row=INT col=INT (width=INT | separator='-sep'))
	 */
	protected void sequence_UnderlyingMaskDefinition(ISerializationContext context, UnderlyingMaskDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     UnderlyingMaskSection returns UnderlyingMaskSection
	 *
	 * Constraint:
	 *     underlyingMaskDefinitions+=TypeMaskDefinition*
	 */
	protected void sequence_UnderlyingMaskSection(ISerializationContext context, UnderlyingMaskSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
